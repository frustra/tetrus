// Generated by CoffeeScript 1.6.3
(function() {
  var _ref, _ref1, _ref2, _ref3, _ref4,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.extend(Batman.config, {
    pathToApp: '/',
    pathToHTML: '/html'
  });

  Batman.View.prototype.cache = false;

  window.Tetrus = (function(_super) {
    __extends(Tetrus, _super);

    function Tetrus() {
      _ref = Tetrus.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Tetrus.layout = 'layout';

    Tetrus.root('landing#index');

    Tetrus.route('lobby', 'lobby#index');

    Tetrus.route('play', 'game#play');

    Tetrus.route('404', 'errors#404');

    Tetrus.on('error', function(event) {
      event.preventDefault();
      console.error(event);
      return Tetrus.Flash.error("Unexpected Error");
    });

    Tetrus.redirectWindow = function(location) {
      return window.location = location;
    };

    Tetrus.flash = function(message) {
      return console.err(message);
    };

    Tetrus.reset = function() {
      if (this.conn) {
        this.conn.close();
        delete this.conn;
      }
      this.set('username', '');
      this.set('peerHash', new Batman.Hash);
      this.off('socket:error');
      this.off('socket:connected');
      return this.off('socket:message');
    };

    Tetrus.setup = function(ready) {
      var _this = this;
      this.conn = new WebSocket("ws://" + (this.get('hostAddr')) + "/play_socket?username=" + (encodeURIComponent(this.get('username'))));
      return Batman.mixin(this.conn, {
        sendJSON: function(obj) {
          return this.send(JSON.stringify(obj));
        },
        onmessage: function(event) {
          var message;
          message = JSON.parse(event.data);
          if (message.error) {
            _this.fire('socket:error', message.error);
            return _this.reset();
          } else if (message.type === 'connected') {
            return _this.fire('socket:connected');
          } else {
            return _this.fire('socket:message', message);
          }
        },
        onopen: function() {
          return _this.fire('socket:opened');
        },
        onclose: function(event) {
          return _this.fire('socket:error', 'Lost Connection');
        },
        onerror: function(event) {
          return _this.fire('socket:error', 'Unexpected Error');
        }
      });
    };

    Tetrus.play = function(invite) {
      this.set('peer', {
        username: invite.get('username'),
        isOfferer: !!invite.get('isSource')
      });
      return Batman.redirect('/play');
    };

    Tetrus.attachGlobalErrorHandler = function() {
      var _this = this;
      return this.on('socket:error', function(err) {
        return Tetrus.Flash.error(err);
      });
    };

    return Tetrus;

  })(Batman.App);

  $(function() {
    Tetrus.set('hostAddr', window.location.host);
    Tetrus.reset();
    return Tetrus.run();
  });

  Tetrus.APIStorage = (function(_super) {
    __extends(APIStorage, _super);

    APIStorage.prototype._addJsonExtension = function(url) {
      if (url.indexOf('?') !== -1 || url.substr(-5, 5) === '.json') {
        return url;
      }
      return url + '.json';
    };

    APIStorage.prototype.urlForRecord = function() {
      return this._addJsonExtension(APIStorage.__super__.urlForRecord.apply(this, arguments));
    };

    APIStorage.prototype.urlForCollection = function() {
      return this._addJsonExtension(APIStorage.__super__.urlForCollection.apply(this, arguments));
    };

    function APIStorage() {
      APIStorage.__super__.constructor.apply(this, arguments);
      this.defaultRequestOptions = {
        type: 'json'
      };
    }

    return APIStorage;

  })(Batman.RestStorage);

  Tetrus.Flash = Batman({
    _message: "",
    _class: "message",
    _flash: function(message) {
      var bottom, node;
      this.set('_message', message);
      node = $('#flash');
      bottom = node.css('bottom');
      return node.animate({
        bottom: 0
      }, 200).delay(5000).animate({
        bottom: bottom
      }, 800);
    },
    message: function(message) {
      this.set('_class', 'message');
      return this._flash(message);
    },
    error: function(error) {
      this.set('_class', 'error');
      return this._flash(error);
    }
  });

  Tetrus.Invite = (function(_super) {
    var x, _fn, _i, _len, _ref2,
      _this = this;

    __extends(Invite, _super);

    function Invite() {
      _ref1 = Invite.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Invite.prototype._sendCommand = function(command) {
      return Tetrus.conn.sendJSON({
        command: "invite:" + command,
        username: this.get('username')
      });
    };

    _ref2 = ['accept', 'reject', 'send'];
    _fn = function(x) {
      return Invite.prototype[x] = function() {
        return this._sendCommand(x);
      };
    };
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      x = _ref2[_i];
      _fn(x);
    }

    return Invite;

  }).call(this, Batman.Model);

  Tetrus.Peer = (function(_super) {
    __extends(Peer, _super);

    function Peer() {
      Peer.__super__.constructor.apply(this, arguments);
    }

    return Peer;

  })(Batman.Model);

  Tetrus.GameController = (function(_super) {
    __extends(GameController, _super);

    function GameController() {
      _ref2 = GameController.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    GameController.prototype.routingKey = 'game';

    GameController.prototype._bindPeerChannel = function(channel) {
      var _this = this;
      this.peerChannel = channel;
      channel.onmessage = function(event) {
        return _this._onMessage(event);
      };
      channel.onopen = function() {
        return console.log("peer channel opened");
      };
      channel.onclose = function() {
        return console.log("peer channel closed");
      };
      return channel.onerror = function() {
        return console.log("peer channel errored");
      };
    };

    GameController.prototype._onMessage = function(event) {
      return console.log(event);
    };

    GameController.prototype.sendMessage = function(node, event, view) {
      var _ref3;
      if ((_ref3 = this.peerChannel) != null) {
        _ref3.send(view.get('message'));
      }
      return view.set('message', '');
    };

    GameController.prototype.play = function() {
      var _this = this;
      this.set('connecting', true);
      this.set('messages', new Batman.Set);
      this.peer = new Tetrus.Peer(Tetrus.get('peer'));
      this.peerConnection = new RTCPeerConnection({
        iceServers: [
          {
            url: 'stun:stun.l.google.com:19302'
          }
        ]
      }, {
        optional: [
          {
            RtpDataChannels: true
          }
        ]
      });
      this.candidates = [];
      this.peerConnection.onicecandidate = function(event) {
        var candidate;
        if (candidate = event.candidate) {
          Batman.developer.log("local candidate", candidate.candidate);
          return _this.candidates.push(candidate);
        }
      };
      this.peerConnection.ondatachannel = function(event) {
        return _this._bindPeerChannel(event.channel);
      };
      if (!this.peer.get('isOfferer')) {
        this._bindPeerChannel(this.peerConnection.createDataChannel('RTCDataChannel'));
        this.peerConnection.createOffer(function(description) {
          _this.peerConnection.setLocalDescription(description);
          Batman.developer.log("local sdp", description.sdp);
          return Tetrus.conn.sendJSON({
            command: 'peer:offer',
            description: description,
            username: _this.peer.get('username')
          });
        }, null, null);
      }
      return Tetrus.on('socket:message', function(message) {
        var candidate, setRemoteDescription, _i, _len, _ref3;
        setRemoteDescription = function() {
          var description;
          description = new RTCSessionDescription(message.description);
          _this.peerConnection.setRemoteDescription(description);
          return Batman.developer.log("remote sdp", description.sdp);
        };
        switch (message.type) {
          case "peer:offer":
            setRemoteDescription();
            return _this.peerConnection.createAnswer(function(description) {
              _this.peerConnection.setLocalDescription(description);
              Batman.developer.log("local sdp", description.sdp);
              return Tetrus.conn.sendJSON({
                command: 'peer:answer',
                description: description
              });
            }, null, null);
          case "peer:answer":
            setRemoteDescription();
            return Tetrus.conn.sendJSON({
              command: 'peer:handshake'
            });
          case "peer:handshake:complete":
            _this.candidates.push = function(candidate) {
              return Tetrus.conn.sendJSON({
                command: 'peer:candidate',
                candidate: candidate
              });
            };
            _ref3 = _this.candidates;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              candidate = _ref3[_i];
              _this.candidates.push(candidate);
            }
            return _this.candidates.length = 0;
          case "peer:candidate":
            candidate = new RTCIceCandidate(message.candidate);
            _this.peerConnection.addIceCandidate(candidate);
            return Batman.developer.log("remote candidate", candidate.candidate);
        }
      });
    };

    return GameController;

  })(Batman.Controller);

  Tetrus.LandingController = (function(_super) {
    __extends(LandingController, _super);

    function LandingController() {
      _ref3 = LandingController.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    LandingController.prototype.routingKey = 'landing';

    LandingController.prototype.index = function() {
      Tetrus.reset();
      if (window.WebSocket == null) {
        this.set('fatal', 'your browser does not support websockets');
      }
      if (!window.webrtcCompatible) {
        return this.set('fatal', 'your browser does not support webrtc');
      }
    };

    LandingController.prototype["continue"] = function() {
      var _this = this;
      Tetrus.on('socket:error', this._socketErrorHandler = function(err) {
        $('#username-error').stop(true).css({
          opacity: 0
        }).animate({
          opacity: 1
        }, 200).delay(2500).animate({
          opacity: 0
        }, 800);
        return _this.set('error', err);
      });
      Tetrus.on('socket:connected', this._socketConnectedHandler = function() {
        Tetrus.off('socket:error', _this._socketErrorHandler);
        Tetrus.off('socket:connected', _this._socketConnectedHandler);
        Tetrus.attachGlobalErrorHandler();
        return Batman.redirect('/lobby');
      });
      return Tetrus.setup();
    };

    return LandingController;

  })(Batman.Controller);

  Tetrus.LobbyController = (function(_super) {
    __extends(LobbyController, _super);

    function LobbyController() {
      _ref4 = LobbyController.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    LobbyController.prototype.routingKey = 'lobby';

    LobbyController.prototype.index = function() {
      this.set('receivedInvites', new Batman.Hash);
      if (!Tetrus.get('username')) {
        Tetrus.redirectWindow('/');
      } else {
        Tetrus.conn.sendJSON({
          command: 'fetch'
        });
      }
      return this._attachSocketListeners();
    };

    LobbyController.prototype._onMessage = function(message) {
      var invite;
      switch (message.type) {
        case "player:joined":
          return Tetrus.get('peerHash').set(message.player.username, message.player);
        case "player:left":
          this.get('receivedInvites').unset(message.player.username);
          return Tetrus.get('peerHash').unset(message.player.username);
        case "invite:accepted":
          this.unset('pending');
          return Tetrus.play(this.unset('sentInvite'));
        case "invite:rejected":
          Tetrus.Flash.message("" + (this.sentInvite.get('username')) + " rejected your invitation");
          this.unset('pending');
          return this.unset('sentInvite');
        case "invite:received":
          this.get('receivedInvites').set(message.invite.username, invite = new Tetrus.Invite(message.invite));
          return Tetrus.Flash.message("Got invitation from " + message.invite.username);
        case "invite:cancelled":
          this.get('receivedInvites').unset(message.invite.username);
          return Tetrus.Flash.message("" + message.invite.username + " cancelled their invitation");
      }
    };

    LobbyController.prototype._attachSocketListeners = function() {
      return Tetrus.on('socket:message', this._boundOnMessage = this._onMessage.bind(this));
    };

    LobbyController.accessor('peers', function() {
      return Tetrus.get('peerHash').map(function(_, value) {
        return value;
      });
    });

    LobbyController.prototype.sendInvite = function(node, event, view) {
      if (this.get('pending')) {
        return Tetrus.Flash.message('You still have a pending invitation');
      } else {
        this.set('sentInvite', new Tetrus.Invite({
          username: view.get('peer').username,
          isSource: true
        })).send();
        return this.set('pending', true);
      }
    };

    LobbyController.prototype.acceptInvite = function(node, event, view) {
      var invite;
      invite = view.get('invite');
      this.get('receivedInvites').unset(invite.get('username'));
      this.get('receivedInvites').forEach(function(invite) {
        return invite.reject();
      });
      invite.accept();
      return Tetrus.play(invite);
    };

    LobbyController.prototype.rejectInvite = function(node, event, view) {
      var invite;
      invite = view.get('invite');
      this.get('receivedInvites').unset(invite.get('username'));
      return invite.reject();
    };

    return LobbyController;

  })(Batman.Controller);

  Tetrus.GamePlayView = (function(_super) {
    __extends(GamePlayView, _super);

    function GamePlayView() {
      GamePlayView.__super__.constructor.apply(this, arguments);
    }

    GamePlayView.prototype.render = function() {};

    return GamePlayView;

  })(Batman.View);

  Tetrus.LayoutView = (function(_super) {
    __extends(LayoutView, _super);

    function LayoutView() {
      var _this = this;
      LayoutView.__super__.constructor.apply(this, arguments);
      Tetrus.observe('currentRoute', function(route) {
        _this.set('routingSection', route.get('controller'));
        return _this.set('routingPage', route.get('action'));
      });
    }

    LayoutView.accessor('title', function() {
      var section;
      section = this.get('routingSection');
      return "" + section + " ~ tetrus";
    });

    LayoutView.accessor('path', function() {
      var section;
      return section = this.get('routingSection');
    });

    return LayoutView;

  })(Batman.View);

}).call(this);
